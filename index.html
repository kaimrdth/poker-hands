<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Hands</title>
    <link rel="icon" type="image/x-icon" href="movicon.ico">
    <style>
        body {
            margin: 0;
            padding: 0px;
            background: #faf9f8;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .container {
            position: relative;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .input-section {
            position: fixed;
            left: 150px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 35px;
            color: #333;
            width: 120px;
        }
        
        .help-message {
            position: fixed;
            left: 150px;
            top: 60%;
            transform: translateY(-50%);
            font-size: 16px;
            color: #999;
            width: 300px;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }
        
        .help-message.fade-in {
            opacity: 1;
        }
        
        .typing-text {
            display: inline;
        }
        
        
        #handInput {
            background: transparent;
            border: none;
            outline: none;
            font-size: inherit;
            font-family: inherit;
            color: transparent;
            min-width: 100px;
            caret-color: transparent;
            transition: none;
        }
        
        #handInput.validated {
            color: #ff0000;
        }
        
        .input-container {
            position: relative;
        }
        
        .input-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            background: transparent;
            border: none;
            outline: none;
            font-size: inherit;
            font-family: inherit;
            color: #333;
            min-width: 100px;
            white-space: pre;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }
        
        .validated-part {
            color: #ff0000;
        }
        
        #canvas {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .error-message {
            color: #999;
            font-size: 16px;
            text-align: center;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }
        
        .error-message.fade-in {
            opacity: .5;
        }
        
        .hand {
            display: flex;
            flex-direction: row;
            gap: 5px;
            position: relative;
            transition: all 0.8s ease;
            border-radius: 15px;
            padding: 10px;
            margin: 5px 0;
        }
        
        .hand.winner {
            background: rgba(34, 197, 94, 0);
            border: 1px solid rgba(0, 255, 94, 0.753);
            box-shadow: 0 0 0px rgba(34, 197, 94, 0.2);
            transition: all 0.8s ease;
            padding-top: 10px;
            padding-bottom: 30px;
        }
        
        .card {
            width: 110px;
            height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 158px;
            background: rgba(255, 255, 255, 0);
            border: 0px solid #ffffff;
            border-radius: 2px;
            box-shadow: 0 0x 0px rgba(0,0,0,0.1);
            position: relative;
        }
        
        .hand-types {
            position: fixed;
            right: 150px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 15px;
            color: #000000bc;
            width: 120px;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }
        
        .hand-types.visible {
            opacity: 1;
        }
        
        .winner-text {
            position: absolute;
            left: 10px;
            top: 1%;
            transform: translateY(50%);
            color: rgba(30, 211, 96, 0.813);
            font-size: 12px;
            font-weight: 500;
            opacity: 0;
            transition: opacity 1.2s ease;
            white-space: nowrap;
        }
        
        .winner-text.visible {
            opacity: 1;
        }
        
        .hand-type-item {
            padding: 8px 0;
            cursor: pointer;
            transition: color .5s ease;
        }
        
        .hand-type-item:hover {
            color: #ff0000;
        }
        
        .hand-type-item.active {
            color: #ff0000;
        }
        
        .hands-container {
            transition: opacity 4.5s ease-in-out;
        }
        
        .hands-container.fading {
            opacity: 0;
        }
        
        .card-back-overlay {
            position: absolute;
            width: 120px;
            height: 162px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 170px;
            color: rgb(2, 2, 192);
            background: white;
            border: 0px solid #ffffff;
            border-radius: 2px;
            box-shadow: 0 0x 0px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .hand {
            position: relative;
        }
        
        .controls {
            position: fixed;
            bottom: 30px;
            right: 40px;
            background: rgba(255, 255, 255, 0.175);
            border: 1px solid #ffffff;
            border-radius: 5px;
            padding: 15px;
            font-size: 12px;
            color: #666666e6;
            opacity: 0;
            transition: opacity 0.5s ease;
            max-width: 250px;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }
        
        .controls.visible {
            opacity: 1;
        }
        
        .control-item {
            margin: 4px 0;
            display: flex;
            justify-content: left;
        }
        
        .control-key {
            font-family: monospace;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
        
        /* Mobile responsive winner text */
        @media (max-width: 768px) {
            .winner-text {
                right: -120px;
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            .winner-text {
                right: -100px;
                font-size: 12px;
            }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 20px 10px;
                min-height: 100vh;
            }
            
            .input-section {
                position: static;
                transform: none;
                width: 100%;
                text-align: center;
                font-size: 24px;
                margin-bottom: 20px;
                left: auto;
                top: auto;
            }
            
            .help-message {
                position: static;
                transform: none;
                width: 100%;
                text-align: center;
                font-size: 14px;
                margin: 10px 0 20px 0;
                left: auto;
                top: auto;
                max-width: 300px;
                margin-left: auto;
                margin-right: auto;
            }
            
            .hand-types {
                position: static;
                transform: none;
                width: 100%;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
                margin: 20px 0;
                right: auto;
                top: auto;
                font-size: 13px;
            }
            
            .hand-type-item {
                padding: 8px 12px;
                background: #f8f8f8;
                border-radius: 15px;
                border: 1px solid #e0e0e0;
                white-space: nowrap;
                min-width: 80px;
                text-align: center;
                transition: all 0.2s ease;
            }
            
            .hand-type-item:hover,
            .hand-type-item.active {
                background: #ff0000;
                color: white;
                border-color: #ff0000;
            }
            
            .card {
                width: 50px;
                height: 74px;
                font-size: 80px;
                border-radius: 4px;
            }
            
            .hand {
                gap: 3px;
                margin: 10px 0;
            }
            
            #canvas {
                gap: 15px;
                width: 100%;
            }
            
            /* Add visual hierarchy for mobile */
            .hand {
                position: relative;
                border-left: 3px solid transparent;
                padding-left: 8px;
                transition: border-color 0.3s ease;
            }
            
            .hand:nth-child(1) { border-left-color: #ff0000; opacity: 1.0; }
            .hand:nth-child(2) { border-left-color: #ff4444; opacity: 0.9; }
            .hand:nth-child(3) { border-left-color: #ff8888; opacity: 0.8; }
            .hand:nth-child(4) { border-left-color: #ffaaaa; opacity: 0.7; }
            .hand:nth-child(5) { border-left-color: #ffcccc; opacity: 0.6; }
            
            .controls {
                position: static;
                width: 100%;
                max-width: none;
                margin-top: 20px;
                background: rgba(248, 248, 248, 0.9);
                text-align: center;
                bottom: auto;
                right: auto;
            }
            
            #handInput {
                font-size: 24px;
                min-width: 200px;
            }
            
            .input-overlay {
                font-size: 24px;
                min-width: 200px;
            }
        }
        
        @media (max-width: 480px) {
            .input-section {
                font-size: 20px;
            }
            
            .card {
                width: 42px;
                height: 62px;
                font-size: 65px;
            }
            
            .hand {
                gap: 2px;
            }
            
            .hand-type-item {
                font-size: 12px;
                padding: 6px 10px;
                min-width: 70px;
            }
            
            #handInput,
            .input-overlay {
                font-size: 20px;
                min-width: 150px;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <div class="input-container">
                <input type="text" id="handInput" placeholder="poker hands" />
                <div id="inputOverlay" class="input-overlay"></div>
            </div>
        </div>
        <div id="canvas"></div>
        <div class="hand-types">
            <div class="hand-type-item" data-hand="royal flush">royal flush</div>
            <div class="hand-type-item" data-hand="straight flush">straight flush</div>
            <div class="hand-type-item" data-hand="four of a kind">four of a kind</div>
            <div class="hand-type-item" data-hand="full house">full house</div>
            <div class="hand-type-item" data-hand="flush">flush</div>
            <div class="hand-type-item" data-hand="straight">straight</div>
            <div class="hand-type-item" data-hand="three of a kind">three of a kind</div>
            <div class="hand-type-item" data-hand="two pair">two pair</div>
            <div class="hand-type-item" data-hand="pair">pair</div>
            <div class="hand-type-item" data-hand="random">random</div>
        </div>
        
        <div class="controls">
            <div class="control-item">
                <span>deal with</span>
                <span class="control-key">enter</span>
            </div>
            <div class="control-item">
                <span>pick new hand with</span>
                <span class="control-key">↑↓</span>
                <span>or start typing</span>

            </div>
        </div>
    </div>
    
    <script>
        const cards = [
            '🂡', '🂢', '🂣', '🂤', '🂥', '🂦', '🂧', '🂨', '🂩', '🂪', '🂫', '🂭', '🂮', // spades
            '🃁', '🃂', '🃃', '🃄', '🃅', '🃆', '🃇', '🃈', '🃉', '🃊', '🃋', '🃍', '🃎', // hearts
            '🃑', '🃒', '🃓', '🃔', '🃕', '🃖', '🃗', '🃘', '🃙', '🃚', '🃛', '🃝', '🃞', // diamonds
            '🂱', '🂲', '🂳', '🂴', '🂵', '🂶', '🂷', '🂸', '🂹', '🂺', '🂻', '🂽', '🂾'  // clubs
        ];
        
        const canvas = document.getElementById('canvas');
        const handInput = document.getElementById('handInput');
        const inputOverlay = document.getElementById('inputOverlay');
        
        // Fisher-Yates shuffle algorithm for proper randomization
        function shuffle(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // Deck state for random dealing
        let remainingDeck = shuffle(cards);
        
        function dealRandomCards(count) {
            // If not enough cards left, reshuffle the deck
            if (remainingDeck.length < count) {
                remainingDeck = shuffle(cards);
            }
            
            // Deal the requested number of cards
            const dealtCards = remainingDeck.splice(0, count);
            return dealtCards;
        }
        
        function updateInputColors(value) {
            const validHandTypes = ['pair', 'two pair', 'three of a kind', 'straight', 'flush', 'full house', 'four of a kind', 'straight flush', 'royal flush', 'random'];
            
            // Always use overlay - input is always transparent
            inputOverlay.style.display = 'block';
            
            // Check for straight flush edge case
            if (value.startsWith('straight ') && !validHandTypes.includes(value.toLowerCase())) {
                const flushPart = value.substring(9); // Everything after "straight "
                if ('flush'.startsWith(flushPart.toLowerCase()) && flushPart.length > 0) {
                    // Mixed coloring: red "straight " + black partial flush
                    inputOverlay.innerHTML = '<span class="validated-part">straight </span>' + flushPart;
                    return;
                }
            }
            
            // Normal coloring based on validation
            if (validHandTypes.includes(value.toLowerCase()) || value.toLowerCase() === 'random') {
                inputOverlay.innerHTML = '<span class="validated-part">' + value.toLowerCase() + '</span>';
            } else {
                inputOverlay.innerHTML = value;
            }
        }
        
        // Typing animation function
        let currentTypingTimeout = null;
        function typeMessage(element, text, speed = 50) {
            return new Promise((resolve) => {
                // Clear any existing typing animation
                if (currentTypingTimeout) {
                    clearTimeout(currentTypingTimeout);
                    currentTypingTimeout = null;
                }
                
                let i = 0;
                element.textContent = '';
                
                function typeChar() {
                    if (i < text.length) {
                        element.textContent += text.charAt(i);
                        i++;
                        currentTypingTimeout = setTimeout(typeChar, speed);
                    } else {
                        currentTypingTimeout = null;
                        resolve();
                    }
                }
                typeChar();
            });
        }
        
        function getHandDefinition(handType) {
            const definitions = {
                'pair': 'two cards of the same rank',
                'two pair': 'two pairs of different ranks', 
                'three of a kind': 'three cards of the same rank',
                'straight': 'five consecutive ranks',
                'flush': 'five cards of the same suit',
                'full house': 'three of a kind plus a pair',
                'four of a kind': 'four cards of the same rank',
                'straight flush': 'straight and flush combined',
                'royal flush': 'A-K-Q-J-10 all same suit',
                'random': 'random five cards'
            };
            return definitions[handType.toLowerCase()] || '';
        }
        
        
        // Auto-refresh variables
        let currentHandType = null;
        let autoRefreshInterval = null;
        let isRefreshing = false;
        let animationTimeouts = [];
        
        // Hand type navigation
        const handTypes = ['royal flush', 'straight flush', 'four of a kind', 'full house', 'flush', 'straight', 'three of a kind', 'two pair', 'pair', 'random'];
        let currentHandIndex = -1;
        let userIsTyping = false;
        let shouldClearOnNextType = false;
        let definitionTimeout;
        
        function getCardValue(card) {
            const spades = ['🂡', '🂢', '🂣', '🂤', '🂥', '🂦', '🂧', '🂨', '🂩', '🂪', '🂫', '🂭', '🂮'];
            const hearts = ['🃁', '🃂', '🃃', '🃄', '🃅', '🃆', '🃇', '🃈', '🃉', '🃊', '🃋', '🃍', '🃎'];
            const diamonds = ['🃑', '🃒', '🃓', '🃔', '🃕', '🃖', '🃗', '🃘', '🃙', '🃚', '🃛', '🃝', '🃞'];
            const clubs = ['🂱', '🂲', '🂳', '🂴', '🂵', '🂶', '🂷', '🂸', '🂹', '🂺', '🂻', '🂽', '🂾'];
            
            let value = 0;
            if (spades.includes(card)) value = spades.indexOf(card) + 1;
            else if (hearts.includes(card)) value = hearts.indexOf(card) + 1;
            else if (diamonds.includes(card)) value = diamonds.indexOf(card) + 1;
            else if (clubs.includes(card)) value = clubs.indexOf(card) + 1;
            
            // Convert Ace from 1 to 14 (highest value)
            return value === 1 ? 14 : value;
        }
        
        function isHandStraight(hand) {
            const values = hand.map(card => getCardValue(card)).sort((a, b) => a - b);
            
            // Check regular straight
            for (let i = 0; i < values.length - 1; i++) {
                if (values[i + 1] - values[i] !== 1) {
                    // Check for wheel straight (A-2-3-4-5)
                    if (values.join(',') === '2,3,4,5,14') return true;
                    return false;
                }
            }
            return true;
        }
        
        function getHandStrength(hand) {
            const values = hand.map(card => getCardValue(card)).sort((a, b) => b - a);
            
            const counts = {};
            values.forEach(v => counts[v] = (counts[v] || 0) + 1);
            const pairs = Object.keys(counts).filter(v => counts[v] === 2).map(Number).sort((a, b) => b - a);
            const trips = Object.keys(counts).filter(v => counts[v] === 3).map(Number);
            const quads = Object.keys(counts).filter(v => counts[v] === 4).map(Number);
            
            // Check for straight
            const isStraight = () => {
                const sortedValues = [...values].sort((a, b) => a - b);
                // Check regular straight
                for (let i = 0; i < sortedValues.length - 1; i++) {
                    if (sortedValues[i + 1] - sortedValues[i] !== 1) {
                        // Check for wheel straight (A-2-3-4-5)
                        if (sortedValues.join(',') === '2,3,4,5,14') return true;
                        return false;
                    }
                }
                return true;
            };
            
            // Check for flush
            const isFlush = () => {
                const suits = hand.map(card => {
                    if (card >= '🂡' && card <= '🂮') return 'spades';
                    if (card >= '🃁' && card <= '🃎') return 'hearts';
                    if (card >= '🃑' && card <= '🃞') return 'diamonds';
                    if (card >= '🂱' && card <= '🂾') return 'clubs';
                });
                return suits.every(suit => suit === suits[0]);
            };
            
            const straight = isStraight();
            const flush = isFlush();
            
            // Hand ranking with proper hierarchy
            if (straight && flush) {
                // Straight flush - use high card, but handle wheel case
                const highCard = values.includes(14) && values.includes(2) ? 5 : Math.max(...values);
                return 8000000 + highCard;
            }
            if (quads.length > 0) return 7000000 + quads[0] * 1000 + values.filter(v => v !== quads[0])[0];
            if (trips.length > 0 && pairs.length > 0) return 6000000 + trips[0] * 1000 + pairs[0];
            if (flush) return 5000000 + values.reduce((sum, v) => sum + v, 0);
            if (straight) {
                // Handle wheel straight (A-2-3-4-5) as 5-high
                const highCard = values.includes(14) && values.includes(2) ? 5 : Math.max(...values);
                return 4000000 + highCard;
            }
            if (trips.length > 0) return 3000000 + trips[0] * 1000 + values.filter(v => v !== trips[0]).slice(0, 2).reduce((sum, v) => sum + v, 0);
            if (pairs.length === 2) return 2000000 + pairs[0] * 1000 + pairs[1] * 100 + values.filter(v => !pairs.includes(v))[0];
            if (pairs.length === 1) return 1000000 + pairs[0] * 1000 + values.filter(v => v !== pairs[0]).slice(0, 3).reduce((sum, v) => sum + v, 0);
            
            // High card - use weighted system to prioritize highest cards
            return values[0] * 10000 + values[1] * 1000 + values[2] * 100 + values[3] * 10 + values[4];
        }

        function getHandType(hand) {
            const values = hand.map(card => getCardValue(card)).sort((a, b) => b - a);
            
            const counts = {};
            values.forEach(v => counts[v] = (counts[v] || 0) + 1);
            const pairs = Object.keys(counts).filter(v => counts[v] === 2).length;
            const trips = Object.keys(counts).filter(v => counts[v] === 3).length;
            const quads = Object.keys(counts).filter(v => counts[v] === 4).length;
            
            // Check for straight
            const isStraight = () => {
                const sortedValues = [...values].sort((a, b) => a - b);
                for (let i = 0; i < sortedValues.length - 1; i++) {
                    if (sortedValues[i + 1] - sortedValues[i] !== 1) {
                        if (sortedValues.join(',') === '2,3,4,5,14') return true;
                        return false;
                    }
                }
                return true;
            };
            
            // Check for flush
            const isFlush = () => {
                const suits = hand.map(card => {
                    if (card >= '🂡' && card <= '🂮') return 'spades';
                    if (card >= '🃁' && card <= '🃎') return 'hearts';
                    if (card >= '🃑' && card <= '🃞') return 'diamonds';
                    if (card >= '🂱' && card <= '🂾') return 'clubs';
                });
                return suits.every(suit => suit === suits[0]);
            };
            
            const straight = isStraight();
            const flush = isFlush();
            
            // Determine hand type
            if (straight && flush) {
                const sortedValues = [...values].sort((a, b) => a - b);
                if (sortedValues.join(',') === '10,11,12,13,14') return 'royal flush';
                return 'straight flush';
            }
            if (quads > 0) return 'four of a kind';
            if (trips > 0 && pairs > 0) return 'full house';
            if (flush) return 'flush';
            if (straight) return 'straight';
            if (trips > 0) return 'three of a kind';
            if (pairs === 2) return 'two pair';
            if (pairs === 1) return 'pair';
            
            return 'high card';
        }
        
        function generatePokerHand(handType) {
            const shuffled = shuffle(cards);
            
            switch(handType.toLowerCase()) {
                case 'pair':
                    return generatePair(shuffled);
                case 'two pair':
                    return generateTwoPair(shuffled);
                case 'three of a kind':
                    return generateThreeOfAKind(shuffled);
                case 'straight':
                    return generateStraight();
                case 'flush':
                    return generateFlush();
                case 'full house':
                    return generateFullHouse(shuffled);
                case 'four of a kind':
                    return generateFourOfAKind(shuffled);
                case 'straight flush':
                    return generateStraightFlush();
                case 'royal flush':
                    return generateRoyalFlush();
                case 'random':
                    return dealRandomCards(5);
                default:
                    return shuffled.slice(0, 5);
            }
        }
        
        function generatePair(shuffled) {
            // Generate pairs with better distribution to ensure variety in strength
            const possibleValues = [14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]; // Ace high to 2 low
            let pairValue = possibleValues[Math.floor(Math.random() * possibleValues.length)];
            
            const pairCards = cards.filter(card => getCardValue(card) === pairValue);
            const pair = pairCards.slice(0, 2);
            
            // Ensure exactly one pair by selecting three different values for kickers
            const availableValues = possibleValues.filter(v => v !== pairValue);
            const kickerValues = [];
            
            // Select 3 different values for kickers
            while (kickerValues.length < 3 && availableValues.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableValues.length);
                kickerValues.push(availableValues.splice(randomIndex, 1)[0]);
            }
            
            // Get one card for each kicker value
            const kickers = kickerValues.map(value => {
                const valueCards = cards.filter(card => getCardValue(card) === value);
                return valueCards[Math.floor(Math.random() * valueCards.length)];
            });
            
            // Sort kickers by value (highest first)
            kickers.sort((a, b) => getCardValue(b) - getCardValue(a));
            return [...pair, ...kickers];
        }
        
        function generateTwoPair(shuffled) {
            let value1 = Math.floor(Math.random() * 13) + 1;
            let value2 = Math.floor(Math.random() * 12) + 1;
            if (value2 >= value1) value2++;
            
            // Convert 1 to 14 for Ace to match getCardValue conversion
            if (value1 === 1) value1 = 14;
            if (value2 === 1) value2 = 14;
            
            const pair1 = cards.filter(card => getCardValue(card) === value1).slice(0, 2);
            const pair2 = cards.filter(card => getCardValue(card) === value2).slice(0, 2);
            const kicker = shuffled.filter(card => getCardValue(card) !== value1 && getCardValue(card) !== value2)[0];
            
            // Order pairs by value (higher pair first)
            if (value1 > value2) {
                return [...pair1, ...pair2, kicker];
            } else {
                return [...pair2, ...pair1, kicker];
            }
        }
        
        function generateThreeOfAKind(shuffled) {
            let tripValue = Math.floor(Math.random() * 13) + 1;
            
            // Convert 1 to 14 for Ace to match getCardValue conversion
            if (tripValue === 1) tripValue = 14;
            
            const trips = cards.filter(card => getCardValue(card) === tripValue).slice(0, 3);
            
            // Ensure exactly three of a kind by selecting two different values for kickers
            const possibleValues = [14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2];
            const availableValues = possibleValues.filter(v => v !== tripValue);
            const kickerValues = [];
            
            // Select 2 different values for kickers
            while (kickerValues.length < 2 && availableValues.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableValues.length);
                kickerValues.push(availableValues.splice(randomIndex, 1)[0]);
            }
            
            // Get one card for each kicker value
            const kickers = kickerValues.map(value => {
                const valueCards = cards.filter(card => getCardValue(card) === value);
                return valueCards[Math.floor(Math.random() * valueCards.length)];
            });
            
            // Sort kickers by value (highest first)
            kickers.sort((a, b) => getCardValue(b) - getCardValue(a));
            return [...trips, ...kickers];
        }
        
        function generateStraight() {
            const straights = [
                [14, 2, 3, 4, 5], // A-2-3-4-5 (wheel - Ace low)
                [2, 3, 4, 5, 6],
                [3, 4, 5, 6, 7],
                [4, 5, 6, 7, 8],
                [5, 6, 7, 8, 9],
                [6, 7, 8, 9, 10],
                [7, 8, 9, 10, 11],
                [8, 9, 10, 11, 12],
                [9, 10, 11, 12, 13],
                [10, 11, 12, 13, 14] // 10-J-Q-K-A (Ace high)
            ];
            const straightValues = straights[Math.floor(Math.random() * straights.length)];
            return straightValues.map(value => {
                const suitCards = cards.filter(card => getCardValue(card) === value);
                return suitCards[Math.floor(Math.random() * suitCards.length)];
            });
        }
        
        function generateFlush() {
            const suits = [
                cards.slice(0, 13),  // spades
                cards.slice(13, 26), // hearts  
                cards.slice(26, 39), // diamonds
                cards.slice(39, 52)  // clubs
            ];
            const selectedSuit = suits[Math.floor(Math.random() * 4)];
            
            let hand;
            let attempts = 0;
            
            // Keep generating until we get a flush that's not a straight
            do {
                const shuffledSuit = shuffle(selectedSuit);
                hand = shuffledSuit.slice(0, 5);
                attempts++;
            } while (isHandStraight(hand) && attempts < 50);
            
            return hand;
        }
        
        function generateFullHouse(shuffled) {
            let tripValue = Math.floor(Math.random() * 13) + 1;
            let pairValue = Math.floor(Math.random() * 12) + 1;
            if (pairValue >= tripValue) pairValue++;
            
            // Convert 1 to 14 for Ace to match getCardValue conversion
            if (tripValue === 1) tripValue = 14;
            if (pairValue === 1) pairValue = 14;
            
            const trips = cards.filter(card => getCardValue(card) === tripValue).slice(0, 3);
            const pair = cards.filter(card => getCardValue(card) === pairValue).slice(0, 2);
            return [...trips, ...pair];
        }
        
        function generateFourOfAKind(shuffled) {
            let quadValue = Math.floor(Math.random() * 13) + 1;
            
            // Convert 1 to 14 for Ace to match getCardValue conversion
            if (quadValue === 1) quadValue = 14;
            
            const quads = cards.filter(card => getCardValue(card) === quadValue);
            const kicker = shuffled.filter(card => getCardValue(card) !== quadValue)[0];
            return [...quads, kicker];
        }
        
        function generateStraightFlush() {
            const suits = [
                cards.slice(0, 13),  // spades
                cards.slice(13, 26), // hearts
                cards.slice(26, 39), // diamonds
                cards.slice(39, 52)  // clubs
            ];
            const selectedSuit = suits[Math.floor(Math.random() * 4)];
            
            const straights = [
                [0, 1, 2, 3, 4],     // A-2-3-4-5 (wheel - indices in suit)
                [1, 2, 3, 4, 5],
                [2, 3, 4, 5, 6],
                [3, 4, 5, 6, 7],
                [4, 5, 6, 7, 8],
                [5, 6, 7, 8, 9],
                [6, 7, 8, 9, 10],
                [7, 8, 9, 10, 11],
                [8, 9, 10, 11, 12],  // 9-10-J-Q-K
                [9, 10, 11, 12, 0]   // 10-J-Q-K-A (Ace high)
            ];
            const straightIndices = straights[Math.floor(Math.random() * straights.length)];
            return straightIndices.map(index => selectedSuit[index]);
        }
        
        function generateRoyalFlush() {
            const suits = [
                cards.slice(0, 13),  // spades
                cards.slice(13, 26), // hearts
                cards.slice(26, 39), // diamonds
                cards.slice(39, 52)  // clubs
            ];
            const selectedSuit = suits[Math.floor(Math.random() * 4)];
            
            // Royal flush is 10-J-Q-K-A (indices 9, 10, 11, 12, 0)
            const royalIndices = [9, 10, 11, 12, 0];
            return royalIndices.map(index => selectedSuit[index]);
        }
        
        function clearAnimationTimeouts() {
            animationTimeouts.forEach(timeout => clearTimeout(timeout));
            animationTimeouts = [];
        }

        function clearWinnerHighlights() {
            const hands = canvas.querySelectorAll('.hand');
            hands.forEach(hand => {
                hand.classList.remove('winner');
                const existingText = hand.querySelector('.winner-text');
                if (existingText) {
                    existingText.classList.remove('visible');
                    // Remove after transition completes
                    setTimeout(() => {
                        if (existingText.parentNode) {
                            existingText.remove();
                        }
                    }, 1200);
                }
            });
        }

        function highlightWinner(container, winnerIndex, handType) {
            const hands = container.querySelectorAll('.hand');
            if (hands[winnerIndex]) {
                // Add winner highlight with smooth delay
                setTimeout(() => {
                    hands[winnerIndex].classList.add('winner');
                    
                    // Add winner text
                    const winnerText = document.createElement('div');
                    winnerText.className = 'winner-text';
                    winnerText.textContent = `${handType} wins`;
                    hands[winnerIndex].appendChild(winnerText);
                    
                    // Show winner text with smooth fade in
                    setTimeout(() => {
                        winnerText.classList.add('visible');
                    }, 600);
                }, 1200);
            }
        }

        async function animateCardReveal(handsContainer, newHands) {
            const hands = handsContainer.querySelectorAll('.hand');
            
            for (let handIndex = 0; handIndex < hands.length; handIndex++) {
                const hand = hands[handIndex];
                const cards = hand.querySelectorAll('.card');
                
                for (let cardIndex = 0; cardIndex < cards.length; cardIndex++) {
                    // Show card back in current position
                    cards[cardIndex].textContent = '🂠';
                    cards[cardIndex].style.color = 'navy';
                    
                    // Wait a moment, then reveal the actual card
                    await new Promise(resolve => {
                        const timeout = setTimeout(() => {
                            // Update to the actual card content
                            const newCard = newHands[handIndex][cardIndex];
                            cards[cardIndex].textContent = newCard;
                            
                            // Color spades and hearts black, diamonds and clubs red
                            if ((newCard >= '🂡' && newCard <= '🂮') || (newCard >= '🃁' && newCard <= '🃎')) {
                                cards[cardIndex].style.color = '#000000'; // spades and hearts black
                            } else if ((newCard >= '🃑' && newCard <= '🃞') || (newCard >= '🂱' && newCard <= '🂾')) {
                                cards[cardIndex].style.color = '#ff0000'; // diamonds and clubs red
                            }
                            
                            resolve();
                        }, 105); // Pause on each card
                        
                        animationTimeouts.push(timeout);
                    });
                }
            }
        }
        
        function displayHands(handType, skipAutoRefresh = false) {
            // Clear any existing animations, winner highlights, and auto-refresh interval
            clearAnimationTimeouts();
            clearWinnerHighlights();
            if (autoRefreshInterval && !skipAutoRefresh) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            
            // Force reset refresh state to allow immediate new animation
            isRefreshing = false;
            
            // Update current hand type
            if (!skipAutoRefresh) {
                currentHandType = handType;
                currentHandIndex = handTypes.indexOf(handType.toLowerCase());
                
                // Update active state on hand type items
                document.querySelectorAll('.hand-type-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll(`.hand-type-item[data-hand="${handType}"]`).forEach(item => {
                    item.classList.add('active');
                });
            }
            
            // Validate hand type
            const validHandTypes = ['pair', 'two pair', 'three of a kind', 'straight', 'flush', 'full house', 'four of a kind', 'straight flush', 'royal flush'];
            if (!validHandTypes.includes(handType.toLowerCase()) && handType.toLowerCase() !== 'random') {
                canvas.innerHTML = '';
                currentHandType = null;
                
                // Only show error message if user is not actively typing and no cards are being dealt
                if (!userIsTyping && !isRefreshing && handType.length > 0) {
                    const errorDiv = document.querySelector('.help-message') || document.createElement('div');
                    if (!document.querySelector('.help-message')) {
                        errorDiv.className = 'help-message';
                        document.body.appendChild(errorDiv);
                    }
                    
                    errorDiv.classList.add('fade-in');
                    typeMessage(errorDiv, 'Try typing: ' + validHandTypes.join(', ') + ', or random', 30);
                    
                    setTimeout(() => {
                        errorDiv.classList.remove('fade-in');
                    }, 6000);
                }
                
                return;
            }
            
            // Generate new hands
            const newHands = [];
            let attempts = 0;
            while (newHands.length < 5 && attempts < 50) {
                const hand = generatePokerHand(handType);
                if (hand && hand.length === 5) {
                    newHands.push(hand);
                } else {
                    console.error('Invalid hand generated:', hand);
                }
                attempts++;
            }
            
            // Fallback: if we still don't have 5 hands, generate random hands
            while (newHands.length < 5) {
                const shuffled = shuffle(cards);
                newHands.push(shuffled.slice(0, 5));
            }
            
            // Sort hands by strength (strongest first for visual hierarchy)
            if (handType.toLowerCase() !== 'random') {
                newHands.sort((a, b) => getHandStrength(b) - getHandStrength(a));
            }
            
            // Find winning hand for random hands
            let winningHandIndex = -1;
            let winningHandType = '';
            if (handType.toLowerCase() === 'random') {
                let bestStrength = -1;
                newHands.forEach((hand, index) => {
                    const strength = getHandStrength(hand);
                    if (strength > bestStrength) {
                        bestStrength = strength;
                        winningHandIndex = index;
                        winningHandType = getHandType(hand);
                    }
                });
            }
            
            // Handle existing hands with animation or create new ones
            const existingContainer = canvas.querySelector('.hands-container');
            if (existingContainer && !isRefreshing) {
                isRefreshing = true;
                
                // Animate the card reveal
                animateCardReveal(existingContainer, newHands).then(() => {
                    isRefreshing = false;
                    // Apply winner highlighting for random hands
                    if (handType.toLowerCase() === 'random' && winningHandIndex >= 0) {
                        highlightWinner(existingContainer, winningHandIndex, winningHandType);
                    }
                });
            } else if (!isRefreshing) {
                // Create hands container for first time - start blank
                isRefreshing = true;
                
                const handsContainer = document.createElement('div');
                handsContainer.className = 'hands-container';
                
                newHands.forEach((hand, handIndex) => {
                    const handDiv = document.createElement('div');
                    handDiv.className = 'hand';
                    
                    hand.forEach(card => {
                        const cardDiv = document.createElement('div');
                        cardDiv.className = 'card';
                        cardDiv.textContent = ''; // Start completely blank
                        cardDiv.style.color = '#000000';
                        
                        handDiv.appendChild(cardDiv);
                    });
                    
                    handsContainer.appendChild(handDiv);
                });
                
                canvas.innerHTML = '';
                canvas.appendChild(handsContainer);
                
                // Show hand types during first hand generation
                setTimeout(() => {
                    document.querySelector('.hand-types').classList.add('visible');
                }, 500);
                
                // Show controls after first hand is dealt
                setTimeout(() => {
                    document.querySelector('.controls').classList.add('visible');
                }, 1000);
                
                // Animate the reveal on blank canvas
                setTimeout(() => {
                    animateCardReveal(handsContainer, newHands).then(() => {
                        isRefreshing = false;
                        // Apply winner highlighting for random hands
                        if (handType.toLowerCase() === 'random' && winningHandIndex >= 0) {
                            highlightWinner(handsContainer, winningHandIndex, winningHandType);
                        }
                    });
                }, 50);
            }
            
            // Start auto-refresh for valid hand types (including random)
            if (!skipAutoRefresh) {
                autoRefreshInterval = setInterval(() => {
                    if (!isRefreshing && currentHandType) {
                        displayHands(currentHandType, true);
                    }
                }, 25000);
            }
        }
        
        handInput.addEventListener('keydown', (e) => {
            if (handChangedByHover && e.key.length === 1) {
                handInput.value = '';
                handChangedByHover = false;
            }
            
            // Clear placeholder after first interaction
            if (handInput.placeholder === 'poker hands') {
                handInput.placeholder = '';
            }
            
            // Handle straight -> straight flush edge case
            if (e.key.length === 1 && handInput.value === 'straight') {
                if (e.key.toLowerCase() === ' ') {
                    e.preventDefault();
                    handInput.value = 'straight ';
                    handInput.setSelectionRange(handInput.value.length, handInput.value.length);
                    shouldClearOnNextType = false; // Don't clear for straight flush
                } else if (e.key.toLowerCase() === 'f') {
                    e.preventDefault();
                    handInput.value = 'straight f';
                    handInput.setSelectionRange(handInput.value.length, handInput.value.length);
                    shouldClearOnNextType = false; // Don't clear for straight flush
                }
            }
            
            // Handle Enter key to re-trigger current hand
            if (e.key === 'Enter') {
                e.preventDefault();
                if (currentHandType) {
                    displayHands(currentHandType);
                    // Don't retrigger definitions - user already knows this hand type
                }
            }
            
            // Handle arrow key navigation
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                
                // Hide any existing definition immediately
                const helpDiv = document.querySelector('.help-message');
                if (helpDiv) {
                    helpDiv.classList.remove('fade-in');
                }
                
                // Clear any pending definition timeout
                if (definitionTimeout) {
                    clearTimeout(definitionTimeout);
                    definitionTimeout = null;
                }
                
                if (e.key === 'ArrowUp') {
                    currentHandIndex = currentHandIndex <= 0 ? handTypes.length - 1 : currentHandIndex - 1;
                } else {
                    currentHandIndex = currentHandIndex >= handTypes.length - 1 ? 0 : currentHandIndex + 1;
                }
                
                const newHandType = handTypes[currentHandIndex];
                handInput.value = newHandType;
                updateInputColors(newHandType);
                displayHands(newHandType);
                
                // Show definition immediately for arrow navigation
                if (definitionTimeout) {
                    clearTimeout(definitionTimeout);
                }
                definitionTimeout = setTimeout(() => {
                    const helpDiv = document.querySelector('.help-message');
                    if (helpDiv) {
                        helpDiv.classList.add('fade-in');
                        const definition = getHandDefinition(newHandType);
                        typeMessage(helpDiv, definition, 40);
                        // Definition stays visible until new hand type is selected
                    }
                }, 100); // Show immediately for arrow navigation
            }
        });
        
        handInput.addEventListener('input', (e) => {
            let value = e.target.value.trim();
            userIsTyping = true;
            
            // Clear input if flag is set (after validated hand)
            if (shouldClearOnNextType) {
                handInput.value = e.data || '';
                value = e.data || '';
                shouldClearOnNextType = false;
                handInput.classList.remove('validated');
            }
            
            // Clear placeholder after first interaction
            if (handInput.placeholder === 'poker hands') {
                handInput.placeholder = '';
            }
            
            // Hide help/definition message when user starts typing new hand
            const helpDiv = document.querySelector('.help-message');
            if (helpDiv) {
                helpDiv.classList.remove('fade-in');
            }
            
            // Clear any pending definition timeout
            if (definitionTimeout) {
                clearTimeout(definitionTimeout);
                definitionTimeout = null;
            }
            
            // Update input colors for current value
            updateInputColors(value);
            
            if (value) {
                const validHandTypes = ['pair', 'two pair', 'three of a kind', 'straight', 'flush', 'full house', 'four of a kind', 'straight flush', 'royal flush'];
                if (validHandTypes.includes(value.toLowerCase()) || value.toLowerCase() === 'random') {
                    // Cancel initial help message if user types valid hand before it appears
                    if (initialHelpTimeout) {
                        clearTimeout(initialHelpTimeout);
                        helpMessageShown = true;
                    }
                    
                    // Only trigger animation for valid hands
                    displayHands(value);
                    
                    // Show current hand type without selection
                    setTimeout(() => {
                        handInput.value = value.toLowerCase();
                        shouldClearOnNextType = true;
                        updateInputColors(value.toLowerCase());
                        
                        // Show definition after 3 seconds
                        if (definitionTimeout) {
                            clearTimeout(definitionTimeout);
                        }
                        definitionTimeout = setTimeout(() => {
                            const helpDiv = document.querySelector('.help-message');
                            if (helpDiv) {
                                helpDiv.classList.add('fade-in');
                                const definition = getHandDefinition(value.toLowerCase());
                                typeMessage(helpDiv, definition, 40);
                                // Definition stays visible until new hand type is selected
                            }
                        }, 50);
                    }, 50);
                }
                // Don't call displayHands for invalid partial input
            } else {
                // Don't clear canvas or stop animations when input is empty
                // Let current hand continue dealing
            }
            
            // Reset typing flag after a longer delay to prevent error messages during typing
            setTimeout(() => {
                userIsTyping = false;
            }, 2000);
        });
        
        // Track if hand was changed by hover
        let handChangedByHover = false;
        
        // Add hover/touch functionality to hand type items
        const handTypeItems = document.querySelectorAll('.hand-type-item');
        handTypeItems.forEach(item => {
            item.addEventListener('mouseenter', () => {
                const handType = item.getAttribute('data-hand');
                displayHands(handType);
                handInput.value = handType;
                handInput.placeholder = '';
                updateInputColors(handType);
                handChangedByHover = true;
                
                // Show definition immediately on hover
                const helpDiv = document.querySelector('.help-message');
                if (helpDiv) {
                    // Clear any pending definition timeout
                    if (definitionTimeout) {
                        clearTimeout(definitionTimeout);
                        definitionTimeout = null;
                    }
                    
                    helpDiv.classList.add('fade-in');
                    const definition = getHandDefinition(handType);
                    typeMessage(helpDiv, definition, 40);
                }
            });
            
            // Add touch/click support for mobile
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const handType = item.getAttribute('data-hand');
                displayHands(handType);
                handInput.value = handType;
                handInput.placeholder = '';
                updateInputColors(handType);
                handChangedByHover = true;
                
                // Show definition immediately on click
                const helpDiv = document.querySelector('.help-message');
                if (helpDiv) {
                    // Clear any pending definition timeout
                    if (definitionTimeout) {
                        clearTimeout(definitionTimeout);
                        definitionTimeout = null;
                    }
                    
                    helpDiv.classList.add('fade-in');
                    const definition = getHandDefinition(handType);
                    typeMessage(helpDiv, definition, 40);
                }
                
                // Don't focus input on mobile to avoid keyboard popup
                if (!isMobile()) {
                    handInput.focus();
                }
            });
            
            // Add touch feedback
            item.addEventListener('touchstart', () => {
                item.style.transform = 'scale(0.95)';
            });
            
            item.addEventListener('touchend', () => {
                item.style.transform = 'scale(1)';
            });
        });

        // Keep textbox always focused on desktop, but allow blur on mobile
        const isMobile = () => window.innerWidth <= 768;
        
        document.addEventListener('click', (e) => {
            // Don't force focus on mobile if clicking hand type items
            if (isMobile() && e.target.closest('.hand-type-item')) {
                return;
            }
            handInput.focus();
        });
        
        handInput.addEventListener('blur', () => {
            // Don't force focus on mobile to allow virtual keyboard to hide
            if (!isMobile()) {
                setTimeout(() => handInput.focus(), 0);
            }
        });

        // Initialize with empty state and focus input
        canvas.innerHTML = '';
        handInput.focus();
        
        // Create help message near input
        const helpDiv = document.createElement('div');
        helpDiv.className = 'help-message';
        document.body.appendChild(helpDiv);
        
        let helpMessageShown = false;
        let initialHelpTimeout;
        
        // Show initial help message sequence with typing animation
        initialHelpTimeout = setTimeout(() => {
            if (!helpMessageShown) {
                helpDiv.classList.add('fade-in');
                typeMessage(helpDiv, 'start typing: pair, two pair, three of a kind, straight, flush, full house, four of a kind, straight flush, royal flush, or random', 30);
                helpMessageShown = true;
                
                // Fade out help message after it's shown
                setTimeout(() => {
                    helpDiv.classList.remove('fade-in');
                }, 6000);
            }
        }, 2000);
    </script>
</body>
</html>